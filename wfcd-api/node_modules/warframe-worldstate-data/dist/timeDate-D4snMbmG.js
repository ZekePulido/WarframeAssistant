//#region tools/timeDate.ts
const epochZero = { $date: { $numberLong: 0 } };
const pieceIsSmoller = (seconds, ceiling, label, timePieces) => {
	if (seconds >= ceiling) {
		timePieces.push(`${Math.floor(seconds / ceiling)}${label}`);
		seconds = Math.floor(seconds) % ceiling;
	}
	return {
		seconds,
		timePieces
	};
};
/**
* @param   {number} millis The number of milliseconds in the time delta
* @returns {string} formatted time delta
*/
const timeDeltaToString = (millis) => {
	if (typeof millis !== "number") throw new TypeError("millis should be a number");
	let timePieces = [];
	const prefix = millis < 0 ? "-" : "";
	let seconds = Math.abs(millis / 1e3);
	({seconds, timePieces} = pieceIsSmoller(seconds, 86400, "d", timePieces));
	({seconds, timePieces} = pieceIsSmoller(seconds, 3600, "h", timePieces));
	({seconds, timePieces} = pieceIsSmoller(seconds, 60, "m", timePieces));
	/* istanbul ignore else */
	if (seconds >= 0) timePieces.push(`${Math.floor(seconds)}s`);
	return `${prefix}${timePieces.join(" ")}`;
};
/**
* Returns the number of milliseconds between now and a given date
* @param   {Date} d         The date from which the current time will be subtracted
* @param   {function} [now] A function that returns the current UNIX time in milliseconds
* @returns {number}       The number of milliseconds after the given date to now
*/
const fromNow = (d, now = Date.now) => {
	return d.getTime() - now();
};
/**
* Returns the number of milliseconds between a given date and now
* @param   {Date} d         The date that the current time will be subtracted from
* @param   {function} [now] A function that returns the current UNIX time in milliseconds
* @returns {number}        The number of milliseconds after now to the given date
*/
const toNow = (d, now = Date.now) => {
	return now() - d.getTime();
};
/**
* Returns a new Date constructed from a worldState date object
* @param {Object} d The worldState date object
* @returns {Date} parsed date from DE date format
*/
const parseDate = (d) => {
	const safeD = d || epochZero;
	const dt = safeD.$date || epochZero.$date;
	return new Date(safeD.$date ? Number(dt.$numberLong) : 1e3 * d.sec);
};
/**
* Get a weekly reset timestamp
*/
const weeklyReset = () => {
	const now = /* @__PURE__ */ new Date();
	const currentDay = now.getUTCDay();
	const daysUntilNextMonday = currentDay === 0 ? 1 : 8 - currentDay;
	const expiry = new Date(now.getTime());
	expiry.setUTCDate(now.getUTCDate() + daysUntilNextMonday);
	expiry.setUTCHours(0, 0, 0, 0);
	const activation = new Date(expiry.getTime());
	activation.setUTCDate(expiry.getUTCDate() - 7);
	return {
		activation,
		expiry
	};
};
/**
* Get a daily reset timestamp
*/
const dailyReset = () => {
	const now = /* @__PURE__ */ new Date();
	const activation = new Date(now.getTime());
	activation.setUTCHours(0, 0, 0, 0);
	const expiry = new Date(now.getTime());
	expiry.setUTCDate(now.getUTCDate() + 1);
	expiry.setUTCHours(0, 0, 0, 0);
	return {
		activation,
		expiry
	};
};
/**
* An object containing functions to format dates and times
* @typedef {Record<string, Function>}           TimeDateFunctions
* @property {Function} timeDeltaToString - Converts a time difference to a string
* @property {Function} fromNow           - Returns the number of milliseconds between now and
*                                          a given date
* @property {Function} toNow             - Returns the number of milliseconds between a given
*                                          date and now
*/
var timeDate_default = {
	timeDeltaToString,
	fromNow,
	toNow,
	parseDate,
	dailyReset,
	weeklyReset
};

//#endregion
export { dailyReset, fromNow, parseDate, timeDate_default, timeDeltaToString, toNow, weeklyReset };